def raw_touch_check():
  step_count_14562abc_45c1_4eba_ba0b_6b7ba55153e3 = 0.0
  thread Step_Counter_Thread_cd47f9e1_419a_40fb_8815_2bfd480f9fd1():
    while (True):
      step_count_14562abc_45c1_4eba_ba0b_6b7ba55153e3 = step_count_14562abc_45c1_4eba_ba0b_6b7ba55153e3 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_cd47f9e1_419a_40fb_8815_2bfd480f9fd1()
  set_tcp(p[0.0,0.0,0.174,0.0,0.0,0.0])
  set_payload(1.0, [0.0, 0.0, 0.07])
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_gravity([0.0, 0.0, 9.82])
  set_tool_communication(True, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(24)
  global test_i_1=1
  global Point_1=p[0.0,0.0,0.0,0.0,0.0,0.0]
  # begin: URCap Installation Node
  #   Source: teleop, 0.8.0, Olis Robotics
  #   Type: Olis Teleop v0.8
  OLIS_SERVER_IP = "192.168.0.100"
  OLIS_TOOL_NAME = "None"
  ##########olis_preamble.script start###########
  
  ### NETWORKING UTILS ###
  def olisOpenSocket(ipaddr, port, name):
  	socket_open_result = socket_open(ipaddr, port, name)
  	if (socket_open_result != True):
  	    textmsg("Cannot open socket to ", name)
  	    return -1
  	else:
  		return 0
  	end
  end
  
  def olisSocketRead(size, name, timeout):
      local olis_socket_buf = socket_read_ascii_float(size,name,timeout)
      # get size as the first index if socket_read_ascii_float works correctly
      if (olis_socket_buf[0] != size): # getting size means data received fine
          if (olis_socket_buf[0] != 0):
              textmsg("Unexpected value of olis_socket_buf[0] = ", olis_socket_buf[0])
              textmsg("size = ", size)
          else:
              textmsg("socket timeout")
          end
          olis_socket_buf[0] = -1
      end
      return olis_socket_buf
  end
  
  ### GLOBAL VARIABLES INITIALIZATION ###
  global shutdown_flag_ = False                          # begin shutdown operation once being set
  global operator_done_ = False
  global commanded_joint_angles_ = [0.,0.,0.,0.,0.,0.]   # servoj function input
  global ready_to_servoj_ = False                        # if True, servoj is allowed to start. Use for confirm all safety needed before moving the robot
  global servoj_controlling_time_ = 0.1                  # servoj function param
  global servoj_lookahead_time_ = 0.1                    # servoj function param
  global servoj_gain_ = 300                              # servoj function param
  global halt_olis_threads_ = False
  global end_session_flag_ = False
  
  ### (int) commanded_control_mode_
  ####-1000: empty heartbeat msg, ignore...
  ### -999: recv_commanded_data not yet updated since synchronization with Olis has not started.
  ### -2: Input joint angles have not yet been initialized on Olis side
  ### -1: Olis has not received actual robot mode from RTDE yet
  ### 0: initial value
  ### 1: joint control
  ### 2: freedrive control
  
  commanded_control_mode_ = 0
  
  ### OLIS NETWORKING THREAD ###
  # this thread exchanges actual data with commanded data from Olis-OS
  thread olisURDataSynchronizationThread():
  	halt_olis_threads = False
      while (not halt_olis_threads):
          ready_to_servoj = False
  
          # recv_commanded_data layout:
          # [0]:size, [1]:commanded_control_mode, [2:7]:commanded_joint_angles, [8]:operator_done_, [9]:servo_j time,
          # [10]:servoj lookahead_time, [11]:servoj gain
          recv_commanded_data = olisSocketRead(11,"olis_server",5.)
          if (recv_commanded_data[0] == -1): # error
              enter_critical ### START MUTEX ###
              ready_to_servoj_ = False
              shutdown_flag_ = True
              exit_critical ### END MUTEX ###
              break
          elif (recv_commanded_data[1] == -1000): #heartbeat msg for socket, ignore message
              enter_critical ### START MUTEX ###
              halt_olis_threads = halt_olis_threads_
              exit_critical ### END MUTEX ###
          	continue
          else:
              commanded_control_mode = recv_commanded_data[1]
              if (commanded_control_mode == 1):
                  ready_to_servoj = True
              else:
                  ready_to_servoj = False
              end
  
              enter_critical ### START MUTEX ###
              commanded_control_mode_ = commanded_control_mode
              if (commanded_control_mode == 1 or commanded_control_mode == 2):
                  i = 0
  	            while i < 6:
  	                commanded_joint_angles_[i] = recv_commanded_data[i+2]
  	                i = i + 1
  	            end
  	            if (recv_commanded_data[8] == 1):
  	            	operator_done_ = True
  	            end
                  servoj_controlling_time_ = recv_commanded_data[9]
                  servoj_lookahead_time_ = recv_commanded_data[10]
                  servoj_gain_ = recv_commanded_data[11]
                  halt_olis_threads = halt_olis_threads_
              end
              ready_to_servoj_ = ready_to_servoj
   			exit_critical ### END MUTEX ###
  
              if (commanded_control_mode == -999):
                  textmsg("recv_commanded_data not yet updated since synchronization with Olis has not started.")
              #elif (commanded_control_mode == -2):
              #    textmsg("Input joint angles have not yet been initialized on Olis side")  #Chose to silence this
              elif (commanded_control_mode == -1):
                  textmsg("Olis has not received actual robot mode from RTDE yet")
              elif (commanded_control_mode == 0):
                  textmsg("commanded_control_mode_ is still initial value and not updated with recv_commanded_data[1]. This must not happen at all")
              end
          end
          sleep(0.008)
      end
      socket_close("olis_server")
  end
  
  
  ### ROBOT MOVEMENT CONTROL THREAD ###
  # This thread controls robot movement regardless of the gripper. Only one thread can have control over robot movement, thus we have both servoj and freedrive control here
  
  thread movementControlThread():
     global freedrive_set_flag_ = False # For verification if freedrive is already on, so it won't be called again.
  
      # need sync after
      def endFreeDrive():
          if (freedrive_set_flag_ == True):
              end_freedrive_mode()
              freedrive_set_flag_ = False
          end
      end
  
      # needs sync after
      def startFreeDrive():
          if (freedrive_set_flag_ == False):
              freedrive_mode()
              freedrive_set_flag_ = True
          end
      end
  
   	halt_olis_threads = False
      while (not halt_olis_threads):
  
          enter_critical ### START MUTEX ###
  		commanded_control_mode = commanded_control_mode_
       	commanded_joint_angles = commanded_joint_angles_
          servoj_controlling_time = servoj_controlling_time_
          servoj_lookahead_time = servoj_lookahead_time_
          servoj_gain = servoj_gain_
          ready_to_servoj = ready_to_servoj_
          halt_olis_threads = halt_olis_threads_
  		exit_critical ### END MUTEX ###
  
          if (commanded_control_mode == 1):
              endFreeDrive() # make sure freedrive mode is not set
              # start servoj only if ready_to_servoj is True which confirms all data has been received
              if (ready_to_servoj == True):
                  servoj(commanded_joint_angles,0,0,servoj_controlling_time,servoj_lookahead_time,servoj_gain)
              end
          elif (commanded_control_mode == 2):
              ready_to_servoj_ = False
              startFreeDrive()
          else:
              endFreeDrive() # make sure freedrive mode is not set
          end
  
          sync()
      end
  end
  
  thread olisMainLoop():
      shutdown_flag = False
  	end_session_flag = False
  
      shutdown_flag_ = False
      operator_done_ = False
      commanded_joint_angles_ = [0.,0.,0.,0.,0.,0.]
      ready_to_servoj_ = False
      servoj_controlling_time_ = 0.1
      servoj_lookahead_time_ = 0.1
      servoj_gain_ = 300
      halt_olis_threads_ = False
      end_session_flag_ = False
  
  
  	olis_ur_data_sync_thread_handle = run olisURDataSynchronizationThread()
  	movement_control_thread_handle = run movementControlThread()
  	TOOL_THREAD_RUN_CODE = 0
  
      while (not shutdown_flag and not end_session_flag):
      	enter_critical ### START MUTEX ###
  		shutdown_flag = shutdown_flag_
  		end_session_flag = end_session_flag_
  		exit_critical ### END MUTEX ###
          sleep(0.05) #don't see the need to check more often than this
      end
  
      enter_critical ### START MUTEX ###
  	halt_olis_threads_ = True
  	exit_critical ### END MUTEX ###
  
      join movement_control_thread_handle
  	join olis_ur_data_sync_thread_handle
  	TOOL_THREAD_JOIN_CODE = 0
  	sync()
  end
  #### olis_preamble.script end ####
  
  # end: URCap Installation Node
  global seek_v=20
  global approach1_p=p[.233098465437, -.416683350523, .053907258737, -2.170613030840, -2.261565526761, -.012256123616]
  global approach1_q=[1.7953318357467651, -1.4227716487697144, 2.1283653418170374, -2.266200681725973, 4.716165542602539, 1.7549076080322266]
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global approach2_p=p[.356172543172, -.318335465349, .053910905097, -2.170632242458, -2.261543933186, -.012267465714]
  global approach2_q=[2.125020980834961, -1.4233334821513672, 2.1295087973224085, -2.26821293453359, 4.719278335571289, 2.0846056938171387]
  def Pick1():
    $ 9 "Pick1" "noBreak"
    $ 10 "MoveL"
    $ 11 "approach1" "breakAfter"
    movel(approach1_p, a=1.2, v=0.25)
    $ 12 "Direction: Tool Z+"
    global move_thread_flag_12=0
    thread move_thread_12():
      enter_critical
      move_thread_flag_12 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,1.0], 0.025)
      movel(towardsPos, a=0.5, v=0.02)
      move_thread_flag_12 = 2
      exit_critical
    end
    move_thread_flag_12 = 0
    move_thread_han_12 = run move_thread_12()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_12
        stopl(1.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.003, normalizedPosDir[1] * 0.003, normalizedPosDir[2] * 0.003, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=1.0, v=0.1)
        $ 13 "Until (tool_contact_detection)"
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag_12 > 1):
        join move_thread_han_12
        $ 14 "Until (distance)"
        break
      end
      sync()
    end
    $ 15 "approach1" "breakAfter"
    movel(approach1_p, a=1.2, v=0.25)
  end
  def Place2():
    $ 16 "Place2" "noBreak"
    $ 17 "MoveL"
    $ 18 "approach2" "breakAfter"
    movel(approach2_p, a=1.2, v=0.25)
    $ 19 "Direction: Tool Z+"
    global move_thread_flag_19=0
    thread move_thread_19():
      enter_critical
      move_thread_flag_19 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,1.0], 1000.0)
      movel(towardsPos, a=0.5, v=0.02)
      move_thread_flag_19 = 2
      exit_critical
    end
    move_thread_flag_19 = 0
    move_thread_han_19 = run move_thread_19()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_19
        stopl(1.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=1.0, v=0.1)
        $ 20 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 21 "approach2" "breakAfter"
    movel(approach2_p, a=1.2, v=0.25)
  end
  def Pick2():
    $ 22 "Pick2" "noBreak"
    $ 23 "MoveL"
    $ 24 "approach2" "breakAfter"
    movel(approach2_p, a=1.2, v=0.25)
    $ 25 "Direction: Tool Z+"
    global move_thread_flag_25=0
    thread move_thread_25():
      enter_critical
      move_thread_flag_25 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,1.0], 0.025)
      movel(towardsPos, a=0.5, v=0.02)
      move_thread_flag_25 = 2
      exit_critical
    end
    move_thread_flag_25 = 0
    move_thread_han_25 = run move_thread_25()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_25
        stopl(1.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.003, normalizedPosDir[1] * 0.003, normalizedPosDir[2] * 0.003, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=1.0, v=0.1)
        $ 26 "Until (tool_contact_detection)"
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag_25 > 1):
        join move_thread_han_25
        $ 27 "Until (distance)"
        break
      end
      sync()
    end
    $ 28 "approach2" "breakAfter"
    movel(approach2_p, a=1.2, v=0.25)
  end
  def Place1():
    $ 29 "Place1" "noBreak"
    $ 30 "MoveL"
    $ 31 "approach1" "breakAfter"
    movel(approach1_p, a=1.2, v=0.25)
    $ 32 "Direction: Tool Z+"
    global move_thread_flag_32=0
    thread move_thread_32():
      enter_critical
      move_thread_flag_32 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,1.0], 1000.0)
      movel(towardsPos, a=0.5, v=0.02)
      move_thread_flag_32 = 2
      exit_critical
    end
    move_thread_flag_32 = 0
    move_thread_han_32 = run move_thread_32()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_32
        stopl(1.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.001, normalizedPosDir[1] * 0.001, normalizedPosDir[2] * 0.001, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=1.0, v=0.1)
        $ 33 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 34 "approach1" "breakAfter"
    movel(approach1_p, a=1.2, v=0.25)
  end
  $ 2 "BeforeStart"
  $ 3 "seek_v≔seek_v"
  global seek_v=seek_v
  while (True):
    $ 4 "Robot Program"
    $ 5 "Call Pick1"
    Pick1()
    $ 6 "Call Place2"
    Place2()
    $ 7 "Call Pick2"
    Pick2()
    $ 8 "Call Place1"
    Place1()
  end
end
